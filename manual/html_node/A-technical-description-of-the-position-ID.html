<html lang="en">
<head>
<title>GNU Backgammon</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Backgammon">
<meta name="generator" content="makeinfo 4.3">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
</head>
<body>
<div class="node">
<p>
Node:<a name="A%20technical%20description%20of%20the%20position%20ID">A technical description of the position ID</a>,
Next:<a rel="next" accesskey="n" href="A-technical-description-of-the-match-ID.html#A%20technical%20description%20of%20the%20match%20ID">A technical description of the match ID</a>,
Up:<a rel="up" accesskey="u" href="Position-and-match-IDs.html#Position%20and%20match%20IDs">Position and match IDs</a>
<hr><br>
</div>

<h3 class="section">A technical description of the position ID</h3>

<h4 class="subsection">Introduction</h4>

   <p>This section describes a method for compactly recording a backgammon
position. It demonstrates how to encode a position into 10 binary
bytes, which is useful for minimising the space used when recording
large numbers of positions in memory or on disk. There is also an
ASCII representation in 14 characters, which is convenient for output
to the screen, for copying and pasting to transfer positions between
programs which support the format, and for communicating positions via
Usenet news or e-mail. The 10 byte binary format is called the <em>key</em>,
and the 14 character ASCII format is the <em>ID</em>.

<h4 class="subsection">Key format</h4>

   <p>The key is essentially a bit string (imagine you start with an empty
sequence of bits, and continue adding either "0" or "1" to the
end). The way to build up a sequence that corresponds to a given
position is:

     <ol type=1 start=1>
<li>For every point around the board (starting at the ace point of
the player on roll, continuing around to the 24 point and ending at
the bar):
          <ol type=1 start=1>
<li>append as many 1s as the player on roll has on that point (if any). 
<li>append a 0.
          </ol>

     <li>For every point around the board (starting at the ace point of
the opponent, continuing around to the opponent's 24 point and ending
at the bar):
          <ol type=1 start=1>
<li>append as many 1s as the opponent has on that point (if any). 
<li>append a 0. 
<li>Pad out the string to 80 bits with 0s.
          </ol>

        </ol>

   <p>The worst-case representation will require 80 bits: you can see that
there are always 50 0 bits even if there are no chequers at all. Each
player has a maximum of 15 chequers in play (not yet borne off) which
require a 1 bit wherever they are positioned. That's 30 bits to take
of all chequers, plus the 50 bits of overhead for a total of 80 bits
(the last bit is always 0 and isn't strictly necessary, but it makes
the code slightly easier). This bit string should be stored in
little-endian order when packed into bytes (ie. the first bits in the
string are stored in the least significant bits of the first byte).

   <p>As an example, here's what the starting position looks like in the key
format:

   <p><table><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">player on roll has no chequers on ace to 5 points
<br></td></tr><tr align="left"><td valign="top">11111 0            </td><td valign="top">5 chequers on the 6 point
<br></td></tr><tr align="left"><td valign="top">0                  </td><td valign="top">empty bar
<br></td></tr><tr align="left"><td valign="top">111 0              </td><td valign="top">3 on the 8
<br></td></tr><tr align="left"><td valign="top">0 0 0 0            </td><td valign="top">no others in our outfield
<br></td></tr><tr align="left"><td valign="top">11111 0            </td><td valign="top">5 on the midpoint
<br></td></tr><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">none in the opponent's outfield
<br></td></tr><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">or in opponent's board, until... 
<br></td></tr><tr align="left"><td valign="top">11 0               </td><td valign="top">two on the 24 point
<br></td></tr><tr align="left"><td valign="top">0                  </td><td valign="top">none on the bar
<br></td></tr><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">opponent has no chequers on ace to 5 points
<br></td></tr><tr align="left"><td valign="top">11111 0            </td><td valign="top">5 chequers on the 6 point
<br></td></tr><tr align="left"><td valign="top">0                  </td><td valign="top">empty bar
<br></td></tr><tr align="left"><td valign="top">111 0              </td><td valign="top">3 on the 8
<br></td></tr><tr align="left"><td valign="top">0 0 0 0            </td><td valign="top">no others in opponent's outfield
<br></td></tr><tr align="left"><td valign="top">11111 0            </td><td valign="top">5 on the midpoint
<br></td></tr><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">none in our outfield
<br></td></tr><tr align="left"><td valign="top">0 0 0 0 0          </td><td valign="top">or in our board, until... 
<br></td></tr><tr align="left"><td valign="top">11 0               </td><td valign="top">two on the 24 point
<br></td></tr><tr align="left"><td valign="top">0                  </td><td valign="top">none on the bar
   <br></td></tr></table>

   <p>so altogether it's:

   <p>00000111110011100000111110000000000011000000011111001110000011111000000000001100

   <p>In little endian bytes it looks like:

   <p>11100000 01110011 11110000 00000001 00110000 11100000 01110011 11110000 00000001 00110000
   0xE0     0x73     0xF0     0x01     0x30     0xE0     0x73     0xF0     0x01     0x30

   <p>so the 10 byte key (in hex) is E0 73 F0 01 30 E0 73 F0 01 30. 
ID format

   <p>The ID format is simply the
<a href="http://www.ietf.org/rfc/rfc2045.txt">Base64</a>
encoding of the key. (Technically,
a Base64 encoding of 80 binary bits should consist of 14 characters
followed by two = padding characters, but this padding is omitted in
the ID format.)

   <p>To continue the above example, splitting the 10 8-bit bytes into 14
6-bit groups gives:

   <p>111000 000111 001111 110000 000000 010011 000011 100000 011100 111111 000000 000001 001100 000000

   <p>In Base64 encoding, these groups are respectively represented as:

   <p>4      H      P     w      A      T      D      g      c      /      A      B      M      A

   <p>So, the position ID of the chequers at the start of the game is simply:

   <p>4HPwATDgc/ABMA

   <p>You can set the board in <tt>gnubg</tt> either by writing the position ID
into the position text input field in the GUI or by executing the
command <code>set board 4HPwATDgc/ABMA</code>.

<h4 class="subsection">Notes</h4>

     <ul>
<li>This encoding is obviously not as compact as it could be: in
particular, there are lots of redundant representations of illegal
positions where both players have chequers on the same
point. Theoretically, it would be possible to get it down to 64 bits
by using
<a href="http://www.bkgm.com/rgb/rgb.cgi?view+371">Walter Trice's "D() expressions"</a>, but I think you'd have to
be a mathematical masochist to try it! 
<li><a href="http://savannah.gnu.org/cgi-bin/viewcvs/gnubg/gnubg/positionid.c?rev=HEAD&amp;sortby=date&amp;content-type=text/vnd.viewcvs-markup">Example code</a>
to convert between a raw board encoding (the number of chequers on
each point) and these keys/IDs is available licensed under GPL. 
<li>Thanks to Tom Keith and David desJardins for their suggestions
on simplifying the encoding without increasing the worst case length. 
</ul>

   </body></html>

